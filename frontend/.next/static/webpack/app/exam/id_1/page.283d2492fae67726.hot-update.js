"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/exam/id_1/page",{

/***/ "(app-pages-browser)/./src/components/proctor/CameraView.tsx":
/*!***********************************************!*\
  !*** ./src/components/proctor/CameraView.tsx ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _modules_proctoring_sdk_services_CameraController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/modules/proctoring-sdk/services/CameraController */ \"(app-pages-browser)/./src/modules/proctoring-sdk/services/CameraController.ts\");\n/* harmony import */ var _modules_vision_ml_vision_faceMesh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/modules/vision-ml/vision/faceMesh */ \"(app-pages-browser)/./src/modules/vision-ml/vision/faceMesh.ts\");\n/* harmony import */ var _modules_vision_ml_vision_gazeEstimator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/modules/vision-ml/vision/gazeEstimator */ \"(app-pages-browser)/./src/modules/vision-ml/vision/gazeEstimator.ts\");\n//Это React-компонент, который ты увидишь на экране.\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nconst CameraView = ()=>{\n    _s();\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"Initializing...\");\n    const [direction, setDirection] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"CENTER\");\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const camera = new _modules_proctoring_sdk_services_CameraController__WEBPACK_IMPORTED_MODULE_2__.CameraController();\n        const ai = new _modules_vision_ml_vision_faceMesh__WEBPACK_IMPORTED_MODULE_3__.FaceMeshService();\n        const estimator = new _modules_vision_ml_vision_gazeEstimator__WEBPACK_IMPORTED_MODULE_4__.GazeEstimator(); // Подключаем логику\n        let animationId;\n        const startSystem = async ()=>{\n            if (videoRef.current && canvasRef.current) {\n                const canvas = canvasRef.current;\n                const ctx = canvas.getContext(\"2d\");\n                // Настраиваем размер канваса под видео\n                canvas.width = 640;\n                canvas.height = 480;\n                try {\n                    camera.attachVideo(videoRef.current);\n                    await camera.start();\n                    setStatus(\"Camera Active. Loading AI...\");\n                    await ai.initialize((results)=>{\n                        // Очищаем рисунок с прошлого кадра\n                        ctx === null || ctx === void 0 ? void 0 : ctx.clearRect(0, 0, canvas.width, canvas.height);\n                        if (results.multiFaceLandmarks.length > 0) {\n                            const landmarks = results.multiFaceLandmarks[0];\n                            // 1. Считаем, куда смотрит студент\n                            const dir = estimator.estimate(landmarks);\n                            setDirection(dir);\n                            setStatus(dir === \"CENTER\" ? \"\\uD83D\\uDFE2 Good\" : \"\\uD83D\\uDD34 WARNING: LOOKING \" + dir);\n                            // 2. Рисуем точки лица (Визуализация)\n                            if (ctx) {\n                                ctx.fillStyle = dir === \"CENTER\" ? \"#00FF00\" : \"#FF0000\";\n                                for (const point of landmarks){\n                                    const x = point.x * canvas.width;\n                                    const y = point.y * canvas.height;\n                                    ctx.beginPath();\n                                    ctx.arc(x, y, 1, 0, 2 * Math.PI); // Маленькая точка\n                                    ctx.fill();\n                                }\n                            }\n                        } else {\n                            setStatus(\"\\uD83D\\uDD34 No Face Detected\");\n                            setDirection(\"CENTER\"); // Сброс\n                        }\n                    });\n                    const loop = async ()=>{\n                        if (videoRef.current) {\n                            await ai.send(videoRef.current);\n                        }\n                        animationId = requestAnimationFrame(loop);\n                    };\n                    loop();\n                } catch (e) {\n                    console.error(e);\n                    setStatus(\"Error starting system\");\n                }\n            }\n        };\n        startSystem();\n        return ()=>{\n            camera.stop();\n            cancelAnimationFrame(animationId);\n        };\n    }, []);\n    // Определяем цвет рамки: Красный если нарушение, Серый если ок\n    const borderColor = direction === \"CENTER\" ? \"border-gray-700\" : \"border-red-500 shadow-[0_0_20px_rgba(255,0,0,0.5)]\";\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"relative w-[640px] h-[480px] bg-black rounded-lg overflow-hidden border-4 transition-all duration-200 \".concat(borderColor),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"video\", {\n                ref: videoRef,\n                className: \"absolute top-0 left-0 w-full h-full object-cover transform -scale-x-100\",\n                playsInline: true,\n                muted: true\n            }, void 0, false, {\n                fileName: \"/Users/hixie/Desktop/uyren_proctoring/frontend/src/components/proctor/CameraView.tsx\",\n                lineNumber: 94,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                ref: canvasRef,\n                className: \"absolute top-0 left-0 w-full h-full transform -scale-x-100\"\n            }, void 0, false, {\n                fileName: \"/Users/hixie/Desktop/uyren_proctoring/frontend/src/components/proctor/CameraView.tsx\",\n                lineNumber: 101,\n                columnNumber: 13\n            }, undefined),\n            direction !== \"CENTER\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-red-600/90 text-white px-6 py-4 rounded-xl text-2xl font-bold animate-pulse\",\n                children: [\n                    \"LOOKING \",\n                    direction,\n                    \"!\"\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/hixie/Desktop/uyren_proctoring/frontend/src/components/proctor/CameraView.tsx\",\n                lineNumber: 108,\n                columnNumber: 17\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute bottom-4 left-4 bg-black/70 text-white px-3 py-1 rounded font-mono\",\n                children: [\n                    \"AI Status: \",\n                    status\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/hixie/Desktop/uyren_proctoring/frontend/src/components/proctor/CameraView.tsx\",\n                lineNumber: 114,\n                columnNumber: 13\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/hixie/Desktop/uyren_proctoring/frontend/src/components/proctor/CameraView.tsx\",\n        lineNumber: 92,\n        columnNumber: 9\n    }, undefined);\n};\n_s(CameraView, \"3udByDYyAneDRu1HXNhr9+Ssvhk=\");\n_c = CameraView;\n/* harmony default export */ __webpack_exports__[\"default\"] = (CameraView);\nvar _c;\n$RefreshReg$(_c, \"CameraView\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3Byb2N0b3IvQ2FtZXJhVmlldy50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLG9EQUFvRDs7O0FBRU87QUFDMkI7QUFDaEI7QUFDa0I7QUFHeEYsTUFBTU8sYUFBYTs7SUFDZixNQUFNQyxXQUFXTiw2Q0FBTUEsQ0FBbUI7SUFDMUMsTUFBTU8sWUFBWVAsNkNBQU1BLENBQW9CO0lBQzVDLE1BQU0sQ0FBQ1EsUUFBUUMsVUFBVSxHQUFHUiwrQ0FBUUEsQ0FBQztJQUNyQyxNQUFNLENBQUNTLFdBQVdDLGFBQWEsR0FBR1YsK0NBQVFBLENBQWdCO0lBRTFERixnREFBU0EsQ0FBQztRQUNOLE1BQU1hLFNBQVMsSUFBSVYsK0ZBQWdCQTtRQUNuQyxNQUFNVyxLQUFLLElBQUlWLCtFQUFlQTtRQUM5QixNQUFNVyxZQUFZLElBQUlWLGtGQUFhQSxJQUFJLG9CQUFvQjtRQUMzRCxJQUFJVztRQUVKLE1BQU1DLGNBQWM7WUFDaEIsSUFBSVYsU0FBU1csT0FBTyxJQUFJVixVQUFVVSxPQUFPLEVBQUU7Z0JBQ3ZDLE1BQU1DLFNBQVNYLFVBQVVVLE9BQU87Z0JBQ2hDLE1BQU1FLE1BQU1ELE9BQU9FLFVBQVUsQ0FBQztnQkFFOUIsdUNBQXVDO2dCQUN2Q0YsT0FBT0csS0FBSyxHQUFHO2dCQUNmSCxPQUFPSSxNQUFNLEdBQUc7Z0JBRWhCLElBQUk7b0JBQ0FWLE9BQU9XLFdBQVcsQ0FBQ2pCLFNBQVNXLE9BQU87b0JBQ25DLE1BQU1MLE9BQU9ZLEtBQUs7b0JBQ2xCZixVQUFVO29CQUVWLE1BQU1JLEdBQUdZLFVBQVUsQ0FBQyxDQUFDQzt3QkFDakIsbUNBQW1DO3dCQUNuQ1AsZ0JBQUFBLDBCQUFBQSxJQUFLUSxTQUFTLENBQUMsR0FBRyxHQUFHVCxPQUFPRyxLQUFLLEVBQUVILE9BQU9JLE1BQU07d0JBRWhELElBQUlJLFFBQVFFLGtCQUFrQixDQUFDQyxNQUFNLEdBQUcsR0FBRzs0QkFDdkMsTUFBTUMsWUFBWUosUUFBUUUsa0JBQWtCLENBQUMsRUFBRTs0QkFFL0MsbUNBQW1DOzRCQUNuQyxNQUFNRyxNQUFNakIsVUFBVWtCLFFBQVEsQ0FBQ0Y7NEJBQy9CbkIsYUFBYW9COzRCQUVidEIsVUFBVXNCLFFBQVEsV0FBVyxzQkFBWSxtQ0FBeUJBOzRCQUVsRSxzQ0FBc0M7NEJBQ3RDLElBQUlaLEtBQUs7Z0NBQ0xBLElBQUljLFNBQVMsR0FBR0YsUUFBUSxXQUFXLFlBQVk7Z0NBQy9DLEtBQUssTUFBTUcsU0FBU0osVUFBVztvQ0FDM0IsTUFBTUssSUFBSUQsTUFBTUMsQ0FBQyxHQUFHakIsT0FBT0csS0FBSztvQ0FDaEMsTUFBTWUsSUFBSUYsTUFBTUUsQ0FBQyxHQUFHbEIsT0FBT0ksTUFBTTtvQ0FDakNILElBQUlrQixTQUFTO29DQUNibEIsSUFBSW1CLEdBQUcsQ0FBQ0gsR0FBR0MsR0FBRyxHQUFHLEdBQUcsSUFBSUcsS0FBS0MsRUFBRSxHQUFHLGtCQUFrQjtvQ0FDcERyQixJQUFJc0IsSUFBSTtnQ0FDWjs0QkFDSjt3QkFDSixPQUFPOzRCQUNIaEMsVUFBVTs0QkFDVkUsYUFBYSxXQUFXLFFBQVE7d0JBQ3BDO29CQUNKO29CQUVBLE1BQU0rQixPQUFPO3dCQUNULElBQUlwQyxTQUFTVyxPQUFPLEVBQUU7NEJBQ2xCLE1BQU1KLEdBQUc4QixJQUFJLENBQUNyQyxTQUFTVyxPQUFPO3dCQUNsQzt3QkFDQUYsY0FBYzZCLHNCQUFzQkY7b0JBQ3hDO29CQUNBQTtnQkFFSixFQUFFLE9BQU9HLEdBQUc7b0JBQ1JDLFFBQVFDLEtBQUssQ0FBQ0Y7b0JBQ2RwQyxVQUFVO2dCQUNkO1lBQ0o7UUFDSjtRQUVBTztRQUVBLE9BQU87WUFDSEosT0FBT29DLElBQUk7WUFDWEMscUJBQXFCbEM7UUFDekI7SUFDSixHQUFHLEVBQUU7SUFFTCwrREFBK0Q7SUFDL0QsTUFBTW1DLGNBQWN4QyxjQUFjLFdBQVcsb0JBQW9CO0lBRWpFLHFCQUNJLDhEQUFDeUM7UUFBSUMsV0FBVyx5R0FBcUgsT0FBWkY7OzBCQUVySCw4REFBQ0c7Z0JBQ0dDLEtBQUtoRDtnQkFDTDhDLFdBQVU7Z0JBQ1ZHLFdBQVc7Z0JBQ1hDLEtBQUs7Ozs7OzswQkFHVCw4REFBQ3RDO2dCQUNHb0MsS0FBSy9DO2dCQUNMNkMsV0FBVTs7Ozs7O1lBSWIxQyxjQUFjLDBCQUNYLDhEQUFDeUM7Z0JBQUlDLFdBQVU7O29CQUF1SjtvQkFDekoxQztvQkFBVTs7Ozs7OzswQkFLM0IsOERBQUN5QztnQkFBSUMsV0FBVTs7b0JBQThFO29CQUM3RTVDOzs7Ozs7Ozs7Ozs7O0FBSTVCO0dBOUdNSDtLQUFBQTtBQWdITiwrREFBZUEsVUFBVUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9wcm9jdG9yL0NhbWVyYVZpZXcudHN4PzA1NTYiXSwic291cmNlc0NvbnRlbnQiOlsiLy/QrdGC0L4gUmVhY3Qt0LrQvtC80L/QvtC90LXQvdGCLCDQutC+0YLQvtGA0YvQuSDRgtGLINGD0LLQuNC00LjRiNGMINC90LAg0Y3QutGA0LDQvdC1LlxuXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQ2FtZXJhQ29udHJvbGxlciB9IGZyb20gJ0AvbW9kdWxlcy9wcm9jdG9yaW5nLXNkay9zZXJ2aWNlcy9DYW1lcmFDb250cm9sbGVyJztcbmltcG9ydCB7IEZhY2VNZXNoU2VydmljZSB9IGZyb20gJ0AvbW9kdWxlcy92aXNpb24tbWwvdmlzaW9uL2ZhY2VNZXNoJztcbmltcG9ydCB7IEdhemVFc3RpbWF0b3IsIEdhemVEaXJlY3Rpb24gfSBmcm9tICdAL21vZHVsZXMvdmlzaW9uLW1sL3Zpc2lvbi9nYXplRXN0aW1hdG9yJztcbmltcG9ydCB7IFJlc3VsdHMgfSBmcm9tIFwiQG1lZGlhcGlwZS9mYWNlX21lc2hcIjtcblxuY29uc3QgQ2FtZXJhVmlldyA9ICgpID0+IHtcbiAgICBjb25zdCB2aWRlb1JlZiA9IHVzZVJlZjxIVE1MVmlkZW9FbGVtZW50PihudWxsKTtcbiAgICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWY8SFRNTENhbnZhc0VsZW1lbnQ+KG51bGwpO1xuICAgIGNvbnN0IFtzdGF0dXMsIHNldFN0YXR1c10gPSB1c2VTdGF0ZShcIkluaXRpYWxpemluZy4uLlwiKTtcbiAgICBjb25zdCBbZGlyZWN0aW9uLCBzZXREaXJlY3Rpb25dID0gdXNlU3RhdGU8R2F6ZURpcmVjdGlvbj4oXCJDRU5URVJcIik7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBjYW1lcmEgPSBuZXcgQ2FtZXJhQ29udHJvbGxlcigpO1xuICAgICAgICBjb25zdCBhaSA9IG5ldyBGYWNlTWVzaFNlcnZpY2UoKTtcbiAgICAgICAgY29uc3QgZXN0aW1hdG9yID0gbmV3IEdhemVFc3RpbWF0b3IoKTsgLy8g0J/QvtC00LrQu9GO0YfQsNC10Lwg0LvQvtCz0LjQutGDXG4gICAgICAgIGxldCBhbmltYXRpb25JZDogbnVtYmVyO1xuXG4gICAgICAgIGNvbnN0IHN0YXJ0U3lzdGVtID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZGVvUmVmLmN1cnJlbnQgJiYgY2FudmFzUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyDQndCw0YHRgtGA0LDQuNCy0LDQtdC8INGA0LDQt9C80LXRgCDQutCw0L3QstCw0YHQsCDQv9C+0LQg0LLQuNC00LXQvlxuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IDY0MDtcbiAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gNDgwO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2FtZXJhLmF0dGFjaFZpZGVvKHZpZGVvUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYW1lcmEuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0U3RhdHVzKFwiQ2FtZXJhIEFjdGl2ZS4gTG9hZGluZyBBSS4uLlwiKTtcblxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBhaS5pbml0aWFsaXplKChyZXN1bHRzOiBSZXN1bHRzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDQntGH0LjRidCw0LXQvCDRgNC40YHRg9C90L7QuiDRgSDQv9GA0L7RiNC70L7Qs9C+INC60LDQtNGA0LBcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eD8uY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzLm11bHRpRmFjZUxhbmRtYXJrcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFuZG1hcmtzID0gcmVzdWx0cy5tdWx0aUZhY2VMYW5kbWFya3NbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMS4g0KHRh9C40YLQsNC10LwsINC60YPQtNCwINGB0LzQvtGC0YDQuNGCINGB0YLRg9C00LXQvdGCXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyID0gZXN0aW1hdG9yLmVzdGltYXRlKGxhbmRtYXJrcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RGlyZWN0aW9uKGRpcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U3RhdHVzKGRpciA9PT0gXCJDRU5URVJcIiA/IFwi8J+foiBHb29kXCIgOiBcIvCflLQgV0FSTklORzogTE9PS0lORyBcIiArIGRpcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyLiDQoNC40YHRg9C10Lwg0YLQvtGH0LrQuCDQu9C40YbQsCAo0JLQuNC30YPQsNC70LjQt9Cw0YbQuNGPKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGRpciA9PT0gXCJDRU5URVJcIiA/IFwiIzAwRkYwMFwiIDogXCIjRkYwMDAwXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgbGFuZG1hcmtzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB4ID0gcG9pbnQueCAqIGNhbnZhcy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBwb2ludC55ICogY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgMSwgMCwgMiAqIE1hdGguUEkpOyAvLyDQnNCw0LvQtdC90YzQutCw0Y8g0YLQvtGH0LrQsFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U3RhdHVzKFwi8J+UtCBObyBGYWNlIERldGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldERpcmVjdGlvbihcIkNFTlRFUlwiKTsgLy8g0KHQsdGA0L7RgVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb29wID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZpZGVvUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBhaS5zZW5kKHZpZGVvUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG9vcCgpO1xuXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICBzZXRTdGF0dXMoXCJFcnJvciBzdGFydGluZyBzeXN0ZW1cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHN0YXJ0U3lzdGVtKCk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNhbWVyYS5zdG9wKCk7XG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25JZCk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuXG4gICAgLy8g0J7Qv9GA0LXQtNC10LvRj9C10Lwg0YbQstC10YIg0YDQsNC80LrQuDog0JrRgNCw0YHQvdGL0Lkg0LXRgdC70Lgg0L3QsNGA0YPRiNC10L3QuNC1LCDQodC10YDRi9C5INC10YHQu9C4INC+0LpcbiAgICBjb25zdCBib3JkZXJDb2xvciA9IGRpcmVjdGlvbiA9PT0gXCJDRU5URVJcIiA/IFwiYm9yZGVyLWdyYXktNzAwXCIgOiBcImJvcmRlci1yZWQtNTAwIHNoYWRvdy1bMF8wXzIwcHhfcmdiYSgyNTUsMCwwLDAuNSldXCI7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YHJlbGF0aXZlIHctWzY0MHB4XSBoLVs0ODBweF0gYmctYmxhY2sgcm91bmRlZC1sZyBvdmVyZmxvdy1oaWRkZW4gYm9yZGVyLTQgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwICR7Ym9yZGVyQ29sb3J9YH0+XG4gICAgICAgICAgICB7Lyog0JLQuNC00LXQviAqL31cbiAgICAgICAgICAgIDx2aWRlbyBcbiAgICAgICAgICAgICAgICByZWY9e3ZpZGVvUmVmfSBcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJhYnNvbHV0ZSB0b3AtMCBsZWZ0LTAgdy1mdWxsIGgtZnVsbCBvYmplY3QtY292ZXIgdHJhbnNmb3JtIC1zY2FsZS14LTEwMFwiXG4gICAgICAgICAgICAgICAgcGxheXNJbmxpbmUgXG4gICAgICAgICAgICAgICAgbXV0ZWQgXG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgey8qINCa0LDQvdCy0LDRgSDQtNC70Y8g0YDQuNGB0L7QstCw0L3QuNGPINGC0L7Rh9C10LogKi99XG4gICAgICAgICAgICA8Y2FudmFzIFxuICAgICAgICAgICAgICAgIHJlZj17Y2FudmFzUmVmfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImFic29sdXRlIHRvcC0wIGxlZnQtMCB3LWZ1bGwgaC1mdWxsIHRyYW5zZm9ybSAtc2NhbGUteC0xMDBcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgey8qINCf0LvQsNGI0LrQsCDRgSDQv9GA0LXQtNGD0L/RgNC10LbQtNC10L3QuNC10LwgKi99XG4gICAgICAgICAgICB7ZGlyZWN0aW9uICE9PSBcIkNFTlRFUlwiICYmIChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIHRvcC0xLzIgbGVmdC0xLzIgdHJhbnNmb3JtIC10cmFuc2xhdGUteC0xLzIgLXRyYW5zbGF0ZS15LTEvMiBiZy1yZWQtNjAwLzkwIHRleHQtd2hpdGUgcHgtNiBweS00IHJvdW5kZWQteGwgdGV4dC0yeGwgZm9udC1ib2xkIGFuaW1hdGUtcHVsc2VcIj5cbiAgICAgICAgICAgICAgICAgICAgTE9PS0lORyB7ZGlyZWN0aW9ufSFcbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICl9XG5cbiAgICAgICAgICAgIHsvKiDQodGC0LDRgtGD0YEg0LHQsNGAICovfVxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhYnNvbHV0ZSBib3R0b20tNCBsZWZ0LTQgYmctYmxhY2svNzAgdGV4dC13aGl0ZSBweC0zIHB5LTEgcm91bmRlZCBmb250LW1vbm9cIj5cbiAgICAgICAgICAgICAgICBBSSBTdGF0dXM6IHtzdGF0dXN9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENhbWVyYVZpZXc7Il0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJDYW1lcmFDb250cm9sbGVyIiwiRmFjZU1lc2hTZXJ2aWNlIiwiR2F6ZUVzdGltYXRvciIsIkNhbWVyYVZpZXciLCJ2aWRlb1JlZiIsImNhbnZhc1JlZiIsInN0YXR1cyIsInNldFN0YXR1cyIsImRpcmVjdGlvbiIsInNldERpcmVjdGlvbiIsImNhbWVyYSIsImFpIiwiZXN0aW1hdG9yIiwiYW5pbWF0aW9uSWQiLCJzdGFydFN5c3RlbSIsImN1cnJlbnQiLCJjYW52YXMiLCJjdHgiLCJnZXRDb250ZXh0Iiwid2lkdGgiLCJoZWlnaHQiLCJhdHRhY2hWaWRlbyIsInN0YXJ0IiwiaW5pdGlhbGl6ZSIsInJlc3VsdHMiLCJjbGVhclJlY3QiLCJtdWx0aUZhY2VMYW5kbWFya3MiLCJsZW5ndGgiLCJsYW5kbWFya3MiLCJkaXIiLCJlc3RpbWF0ZSIsImZpbGxTdHlsZSIsInBvaW50IiwieCIsInkiLCJiZWdpblBhdGgiLCJhcmMiLCJNYXRoIiwiUEkiLCJmaWxsIiwibG9vcCIsInNlbmQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJlIiwiY29uc29sZSIsImVycm9yIiwic3RvcCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiYm9yZGVyQ29sb3IiLCJkaXYiLCJjbGFzc05hbWUiLCJ2aWRlbyIsInJlZiIsInBsYXlzSW5saW5lIiwibXV0ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/proctor/CameraView.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/modules/vision-ml/vision/gazeEstimator.ts":
/*!*******************************************************!*\
  !*** ./src/modules/vision-ml/vision/gazeEstimator.ts ***!
  \*******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GazeEstimator: function() { return /* binding */ GazeEstimator; }\n/* harmony export */ });\n//сравнивает положение носа с краями лица (скулами). Если нос слишком близко к левой скуле — значит, голова повернута влево.\nclass GazeEstimator {\n    estimate(landmarks) {\n        const nose = landmarks[this.LANDMARKS.NOSE_TIP];\n        const leftCheek = landmarks[this.LANDMARKS.LEFT_CHEEK];\n        const rightCheek = landmarks[this.LANDMARKS.RIGHT_CHEEK];\n        const chin = landmarks[this.LANDMARKS.CHIN];\n        const forehead = landmarks[this.LANDMARKS.FOREHEAD];\n        // 1. Вычисляем ширину лица\n        const faceWidth = rightCheek.x - leftCheek.x;\n        // 2. Вычисляем где находится нос относительно центра (от 0 до 1)\n        // 0.5 - это идеально по центру между щеками\n        const noseRelativePos = (nose.x - leftCheek.x) / faceWidth;\n        // 3. Логика поворота (Зеркальная логика, т.к. камера зеркалит)\n        // Если нос ближе к одной из щек\n        if (noseRelativePos < 0.5 - this.THRESHOLDS.HORIZONTAL) {\n            return \"RIGHT\"; // Для пользователя это поворот вправо\n        }\n        if (noseRelativePos > 0.5 + this.THRESHOLDS.HORIZONTAL) {\n            return \"LEFT\"; // Для пользователя это поворот влево\n        }\n        // 4. Логика наклона (вверх/вниз)\n        const faceHeight = chin.y - forehead.y;\n        const noseRelativeY = (nose.y - forehead.y) / faceHeight;\n        if (noseRelativeY < 0.5 - this.THRESHOLDS.VERTICAL) return \"UP\";\n        if (noseRelativeY > 0.5 + this.THRESHOLDS.VERTICAL) return \"DOWN\";\n        return \"CENTER\";\n    }\n    constructor(){\n        // Индексы точек лица в MediaPipe (стандартные)\n        this.LANDMARKS = {\n            NOSE_TIP: 1,\n            LEFT_CHEEK: 234,\n            RIGHT_CHEEK: 454,\n            CHIN: 152,\n            FOREHEAD: 10\n        };\n        // Настройки чувствительности (можно менять)\n        this.THRESHOLDS = {\n            HORIZONTAL: 0.25,\n            VERTICAL: 0.15\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9tb2R1bGVzL3Zpc2lvbi1tbC92aXNpb24vZ2F6ZUVzdGltYXRvci50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsNEhBQTRIO0FBS3JILE1BQU1BO0lBZ0JGQyxTQUFTQyxTQUErQixFQUFpQjtRQUM1RCxNQUFNQyxPQUFPRCxTQUFTLENBQUMsSUFBSSxDQUFDRSxTQUFTLENBQUNDLFFBQVEsQ0FBQztRQUMvQyxNQUFNQyxZQUFZSixTQUFTLENBQUMsSUFBSSxDQUFDRSxTQUFTLENBQUNHLFVBQVUsQ0FBQztRQUN0RCxNQUFNQyxhQUFhTixTQUFTLENBQUMsSUFBSSxDQUFDRSxTQUFTLENBQUNLLFdBQVcsQ0FBQztRQUN4RCxNQUFNQyxPQUFPUixTQUFTLENBQUMsSUFBSSxDQUFDRSxTQUFTLENBQUNPLElBQUksQ0FBQztRQUMzQyxNQUFNQyxXQUFXVixTQUFTLENBQUMsSUFBSSxDQUFDRSxTQUFTLENBQUNTLFFBQVEsQ0FBQztRQUVuRCwyQkFBMkI7UUFDM0IsTUFBTUMsWUFBWU4sV0FBV08sQ0FBQyxHQUFHVCxVQUFVUyxDQUFDO1FBRTVDLGlFQUFpRTtRQUNqRSw0Q0FBNEM7UUFDNUMsTUFBTUMsa0JBQWtCLENBQUNiLEtBQUtZLENBQUMsR0FBR1QsVUFBVVMsQ0FBQyxJQUFJRDtRQUVqRCwrREFBK0Q7UUFDL0QsZ0NBQWdDO1FBQ2hDLElBQUlFLGtCQUFrQixNQUFNLElBQUksQ0FBQ0MsVUFBVSxDQUFDQyxVQUFVLEVBQUU7WUFDcEQsT0FBTyxTQUFTLHNDQUFzQztRQUMxRDtRQUNBLElBQUlGLGtCQUFrQixNQUFNLElBQUksQ0FBQ0MsVUFBVSxDQUFDQyxVQUFVLEVBQUU7WUFDcEQsT0FBTyxRQUFRLHFDQUFxQztRQUN4RDtRQUVBLGlDQUFpQztRQUNqQyxNQUFNQyxhQUFhVCxLQUFLVSxDQUFDLEdBQUdSLFNBQVNRLENBQUM7UUFDdEMsTUFBTUMsZ0JBQWdCLENBQUNsQixLQUFLaUIsQ0FBQyxHQUFHUixTQUFTUSxDQUFDLElBQUlEO1FBRTlDLElBQUlFLGdCQUFnQixNQUFNLElBQUksQ0FBQ0osVUFBVSxDQUFDSyxRQUFRLEVBQUUsT0FBTztRQUMzRCxJQUFJRCxnQkFBZ0IsTUFBTSxJQUFJLENBQUNKLFVBQVUsQ0FBQ0ssUUFBUSxFQUFFLE9BQU87UUFFM0QsT0FBTztJQUNYOztRQTlDQSwrQ0FBK0M7YUFDOUJsQixZQUFZO1lBQ3pCQyxVQUFVO1lBQ1ZFLFlBQVk7WUFDWkUsYUFBYTtZQUNiRSxNQUFNO1lBQ05FLFVBQVU7UUFDZDtRQUVBLDRDQUE0QzthQUMzQkksYUFBYTtZQUMxQkMsWUFBWTtZQUNaSSxVQUFVO1FBQ2Q7O0FBa0NKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9tb2R1bGVzL3Zpc2lvbi1tbC92aXNpb24vZ2F6ZUVzdGltYXRvci50cz9hZTc5Il0sInNvdXJjZXNDb250ZW50IjpbIi8v0YHRgNCw0LLQvdC40LLQsNC10YIg0L/QvtC70L7QttC10L3QuNC1INC90L7RgdCwINGBINC60YDQsNGP0LzQuCDQu9C40YbQsCAo0YHQutGD0LvQsNC80LgpLiDQldGB0LvQuCDQvdC+0YEg0YHQu9C40YjQutC+0Lwg0LHQu9C40LfQutC+INC6INC70LXQstC+0Lkg0YHQutGD0LvQtSDigJQg0LfQvdCw0YfQuNGCLCDQs9C+0LvQvtCy0LAg0L/QvtCy0LXRgNC90YPRgtCwINCy0LvQtdCy0L4uXG5pbXBvcnQgeyBOb3JtYWxpemVkTGFuZG1hcmsgfSBmcm9tIFwiQG1lZGlhcGlwZS9mYWNlX21lc2hcIjtcblxuZXhwb3J0IHR5cGUgR2F6ZURpcmVjdGlvbiA9IFwiQ0VOVEVSXCIgfCBcIkxFRlRcIiB8IFwiUklHSFRcIiB8IFwiVVBcIiB8IFwiRE9XTlwiO1xuXG5leHBvcnQgY2xhc3MgR2F6ZUVzdGltYXRvciB7XG4gICAgLy8g0JjQvdC00LXQutGB0Ysg0YLQvtGH0LXQuiDQu9C40YbQsCDQsiBNZWRpYVBpcGUgKNGB0YLQsNC90LTQsNGA0YLQvdGL0LUpXG4gICAgcHJpdmF0ZSByZWFkb25seSBMQU5ETUFSS1MgPSB7XG4gICAgICAgIE5PU0VfVElQOiAxLFxuICAgICAgICBMRUZUX0NIRUVLOiAyMzQsICAvLyDQm9C10LLRi9C5INC60YDQsNC5INC70LjRhtCwXG4gICAgICAgIFJJR0hUX0NIRUVLOiA0NTQsIC8vINCf0YDQsNCy0YvQuSDQutGA0LDQuSDQu9C40YbQsFxuICAgICAgICBDSElOOiAxNTIsXG4gICAgICAgIEZPUkVIRUFEOiAxMFxuICAgIH07XG5cbiAgICAvLyDQndCw0YHRgtGA0L7QudC60Lgg0YfRg9Cy0YHRgtCy0LjRgtC10LvRjNC90L7RgdGC0LggKNC80L7QttC90L4g0LzQtdC90Y/RgtGMKVxuICAgIHByaXZhdGUgcmVhZG9ubHkgVEhSRVNIT0xEUyA9IHtcbiAgICAgICAgSE9SSVpPTlRBTDogMC4yNSwgLy8g0KfQtdC8INC80LXQvdGM0YjQtSDRh9C40YHQu9C+LCDRgtC10Lwg0YHRgtGA0L7QttC1INC/0YDQvtCy0LXRgNC60LBcbiAgICAgICAgVkVSVElDQUw6IDAuMTVcbiAgICB9O1xuXG4gICAgcHVibGljIGVzdGltYXRlKGxhbmRtYXJrczogTm9ybWFsaXplZExhbmRtYXJrW10pOiBHYXplRGlyZWN0aW9uIHtcbiAgICAgICAgY29uc3Qgbm9zZSA9IGxhbmRtYXJrc1t0aGlzLkxBTkRNQVJLUy5OT1NFX1RJUF07XG4gICAgICAgIGNvbnN0IGxlZnRDaGVlayA9IGxhbmRtYXJrc1t0aGlzLkxBTkRNQVJLUy5MRUZUX0NIRUVLXTtcbiAgICAgICAgY29uc3QgcmlnaHRDaGVlayA9IGxhbmRtYXJrc1t0aGlzLkxBTkRNQVJLUy5SSUdIVF9DSEVFS107XG4gICAgICAgIGNvbnN0IGNoaW4gPSBsYW5kbWFya3NbdGhpcy5MQU5ETUFSS1MuQ0hJTl07XG4gICAgICAgIGNvbnN0IGZvcmVoZWFkID0gbGFuZG1hcmtzW3RoaXMuTEFORE1BUktTLkZPUkVIRUFEXTtcblxuICAgICAgICAvLyAxLiDQktGL0YfQuNGB0LvRj9C10Lwg0YjQuNGA0LjQvdGDINC70LjRhtCwXG4gICAgICAgIGNvbnN0IGZhY2VXaWR0aCA9IHJpZ2h0Q2hlZWsueCAtIGxlZnRDaGVlay54O1xuICAgICAgICBcbiAgICAgICAgLy8gMi4g0JLRi9GH0LjRgdC70Y/QtdC8INCz0LTQtSDQvdCw0YXQvtC00LjRgtGB0Y8g0L3QvtGBINC+0YLQvdC+0YHQuNGC0LXQu9GM0L3QviDRhtC10L3RgtGA0LAgKNC+0YIgMCDQtNC+IDEpXG4gICAgICAgIC8vIDAuNSAtINGN0YLQviDQuNC00LXQsNC70YzQvdC+INC/0L4g0YbQtdC90YLRgNGDINC80LXQttC00YMg0YnQtdC60LDQvNC4XG4gICAgICAgIGNvbnN0IG5vc2VSZWxhdGl2ZVBvcyA9IChub3NlLnggLSBsZWZ0Q2hlZWsueCkgLyBmYWNlV2lkdGg7XG5cbiAgICAgICAgLy8gMy4g0JvQvtCz0LjQutCwINC/0L7QstC+0YDQvtGC0LAgKNCX0LXRgNC60LDQu9GM0L3QsNGPINC70L7Qs9C40LrQsCwg0YIu0LouINC60LDQvNC10YDQsCDQt9C10YDQutCw0LvQuNGCKVxuICAgICAgICAvLyDQldGB0LvQuCDQvdC+0YEg0LHQu9C40LbQtSDQuiDQvtC00L3QvtC5INC40Lcg0YnQtdC6XG4gICAgICAgIGlmIChub3NlUmVsYXRpdmVQb3MgPCAwLjUgLSB0aGlzLlRIUkVTSE9MRFMuSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiUklHSFRcIjsgLy8g0JTQu9GPINC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRjyDRjdGC0L4g0L/QvtCy0L7RgNC+0YIg0LLQv9GA0LDQstC+XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vc2VSZWxhdGl2ZVBvcyA+IDAuNSArIHRoaXMuVEhSRVNIT0xEUy5IT1JJWk9OVEFMKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJMRUZUXCI7IC8vINCU0LvRjyDQv9C+0LvRjNC30L7QstCw0YLQtdC70Y8g0Y3RgtC+INC/0L7QstC+0YDQvtGCINCy0LvQtdCy0L5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDQuINCb0L7Qs9C40LrQsCDQvdCw0LrQu9C+0L3QsCAo0LLQstC10YDRhS/QstC90LjQtylcbiAgICAgICAgY29uc3QgZmFjZUhlaWdodCA9IGNoaW4ueSAtIGZvcmVoZWFkLnk7XG4gICAgICAgIGNvbnN0IG5vc2VSZWxhdGl2ZVkgPSAobm9zZS55IC0gZm9yZWhlYWQueSkgLyBmYWNlSGVpZ2h0O1xuXG4gICAgICAgIGlmIChub3NlUmVsYXRpdmVZIDwgMC41IC0gdGhpcy5USFJFU0hPTERTLlZFUlRJQ0FMKSByZXR1cm4gXCJVUFwiO1xuICAgICAgICBpZiAobm9zZVJlbGF0aXZlWSA+IDAuNSArIHRoaXMuVEhSRVNIT0xEUy5WRVJUSUNBTCkgcmV0dXJuIFwiRE9XTlwiO1xuXG4gICAgICAgIHJldHVybiBcIkNFTlRFUlwiO1xuICAgIH1cbn0iXSwibmFtZXMiOlsiR2F6ZUVzdGltYXRvciIsImVzdGltYXRlIiwibGFuZG1hcmtzIiwibm9zZSIsIkxBTkRNQVJLUyIsIk5PU0VfVElQIiwibGVmdENoZWVrIiwiTEVGVF9DSEVFSyIsInJpZ2h0Q2hlZWsiLCJSSUdIVF9DSEVFSyIsImNoaW4iLCJDSElOIiwiZm9yZWhlYWQiLCJGT1JFSEVBRCIsImZhY2VXaWR0aCIsIngiLCJub3NlUmVsYXRpdmVQb3MiLCJUSFJFU0hPTERTIiwiSE9SSVpPTlRBTCIsImZhY2VIZWlnaHQiLCJ5Iiwibm9zZVJlbGF0aXZlWSIsIlZFUlRJQ0FMIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/modules/vision-ml/vision/gazeEstimator.ts\n"));

/***/ })

});